{
  "name": "dropzone",
  "type": "registry:ui",
  "registryDependencies": [
    "button"
  ],
  "dependencies": [
    "react-dropzone"
  ],
  "devDependencies": [],
  "tailwind": {},
  "cssVars": {
    "light": {},
    "dark": {}
  },
  "files": [
    {
      "path": "dropzone.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-empty-object-type */\nimport { cn } from \"@/lib/utils\";\nimport {\n  createContext,\n  forwardRef,\n  useCallback,\n  useContext,\n  useId,\n  useMemo,\n  useReducer,\n  useState,\n} from \"react\";\nimport {\n  Accept,\n  FileRejection,\n  useDropzone as rootUseDropzone,\n} from \"react-dropzone\";\nimport { Button, ButtonProps } from \"./ui/button\";\n\ntype DropzoneResult<TUploadRes, TUploadError> =\n  | {\n      status: \"pending\";\n    }\n  | {\n      status: \"error\";\n      error: TUploadError;\n    }\n  | {\n      status: \"success\";\n      result: TUploadRes;\n    };\n\nexport type FileStatus<TUploadRes, TUploadError> = {\n  id: string;\n  fileName: string;\n  file: File;\n  tries: number;\n} & (\n  | {\n      status: \"pending\";\n      result?: undefined;\n      error?: undefined;\n    }\n  | {\n      status: \"error\";\n      error: TUploadError;\n      result?: undefined;\n    }\n  | {\n      status: \"success\";\n      result: TUploadRes;\n      error?: undefined;\n    }\n);\n\nconst fileStatusReducer = <TUploadRes, TUploadError>(\n  state: FileStatus<TUploadRes, TUploadError>[],\n  action:\n    | {\n        type: \"add\";\n        id: string;\n        fileName: string;\n        file: File;\n      }\n    | {\n        type: \"remove\";\n        id: string;\n      }\n    | ({\n        type: \"update-status\";\n        id: string;\n      } & DropzoneResult<TUploadRes, TUploadError>),\n): FileStatus<TUploadRes, TUploadError>[] => {\n  switch (action.type) {\n    case \"add\":\n      return [\n        ...state,\n        {\n          id: action.id,\n          fileName: action.fileName,\n          file: action.file,\n          status: \"pending\",\n          tries: 1,\n        },\n      ];\n    case \"remove\":\n      return state.filter((fileStatus) => fileStatus.id !== action.id);\n    case \"update-status\":\n      return state.map((fileStatus) => {\n        if (fileStatus.id === action.id) {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const { id, type, ...rest } = action;\n          return {\n            ...fileStatus,\n            ...rest,\n            tries:\n              action.status === \"pending\"\n                ? fileStatus.tries + 1\n                : fileStatus.tries,\n          } as FileStatus<TUploadRes, TUploadError>;\n        }\n        return fileStatus;\n      });\n  }\n};\ntype DropZoneErrorCode = (typeof dropZoneErrorCodes)[number];\nconst dropZoneErrorCodes = [\n  \"file-invalid-type\",\n  \"file-too-large\",\n  \"file-too-small\",\n  \"too-many-files\",\n] as const;\n\nconst getDropZoneErrorCodes = (fileRejections: FileRejection[]) => {\n  const errors = fileRejections.map((rejection) => {\n    return rejection.errors\n      .filter((error) =>\n        dropZoneErrorCodes.includes(error.code as DropZoneErrorCode),\n      )\n      .map((error) => error.code) as DropZoneErrorCode[];\n  });\n  return Array.from(new Set(errors.flat()));\n};\n\nconst getRootError = (\n  errorCodes: DropZoneErrorCode[],\n  limits: {\n    accept?: Accept;\n    maxSize?: number;\n    minSize?: number;\n    maxFiles?: number;\n  },\n) => {\n  const errors = errorCodes.map((error) => {\n    switch (error) {\n      case \"file-invalid-type\":\n        const acceptedTypes = Object.values(limits.accept ?? {})\n          .flat()\n          .join(\", \");\n        return `only ${acceptedTypes} are allowed`;\n      case \"file-too-large\":\n        const maxMb = limits.maxSize\n          ? (limits.maxSize / (1024 * 1024)).toFixed(2)\n          : \"infinite?\";\n        return `max size is ${maxMb}MB`;\n      case \"file-too-small\":\n        const roundedMinSize = limits.minSize\n          ? (limits.minSize / (1024 * 1024)).toFixed(2)\n          : \"negative?\";\n        return `min size is ${roundedMinSize}MB`;\n      case \"too-many-files\":\n        return `max ${limits.maxFiles} files`;\n    }\n  });\n  const joinedErrors = errors.join(\", \");\n  return joinedErrors.charAt(0).toUpperCase() + joinedErrors.slice(1);\n};\n\ntype UseDropzoneProps<TUploadRes, TUploadError> = {\n  onDropFile: (\n    file: File,\n  ) => Promise<\n    Exclude<DropzoneResult<TUploadRes, TUploadError>, { status: \"pending\" }>\n  >;\n  onRemoveFile?: (id: string) => void | Promise<void>;\n  onFileUploaded?: (result: TUploadRes) => void;\n  onFileUploadError?: (error: TUploadError) => void;\n  onAllUploaded?: () => void;\n  onRootError?: (error: string | undefined) => void;\n  maxRetryCount?: number;\n  autoRetry?: boolean;\n  validation?: {\n    accept?: Accept;\n    minSize?: number;\n    maxSize?: number;\n    maxFiles?: number;\n  };\n  shiftOnMaxFiles?: boolean;\n} & (TUploadError extends string\n  ? {\n      shapeUploadError?: (error: TUploadError) => string | void;\n    }\n  : {\n      shapeUploadError: (error: TUploadError) => string | void;\n    });\n\ninterface UseDropzoneReturn<TUploadRes, TUploadError> {\n  getRootProps: ReturnType<typeof rootUseDropzone>[\"getRootProps\"];\n  getInputProps: ReturnType<typeof rootUseDropzone>[\"getInputProps\"];\n  onRemoveFile: (id: string) => Promise<void>;\n  onRetry: (id: string) => Promise<void>;\n  canRetry: (id: string) => boolean;\n  fileStatuses: FileStatus<TUploadRes, TUploadError>[];\n  isInvalid: boolean;\n  isDragActive: boolean;\n  rootError: string | undefined;\n  inputId: string;\n  rootMessageId: string;\n  rootDescriptionId: string;\n  getFileMessageId: (id: string) => string;\n}\n\nconst useDropzone = <TUploadRes, TUploadError = string>(\n  props: UseDropzoneProps<TUploadRes, TUploadError>,\n): UseDropzoneReturn<TUploadRes, TUploadError> => {\n  const {\n    onDropFile: pOnDropFile,\n    onRemoveFile: pOnRemoveFile,\n    shapeUploadError: pShapeUploadError,\n    onFileUploaded: pOnFileUploaded,\n    onFileUploadError: pOnFileUploadError,\n    onAllUploaded: pOnAllUploaded,\n    onRootError: pOnRootError,\n    maxRetryCount,\n    autoRetry,\n    validation,\n    shiftOnMaxFiles,\n  } = props;\n\n  const inputId = useId();\n  const rootMessageId = `${inputId}-root-message`;\n  const rootDescriptionId = `${inputId}-description`;\n  const [rootError, _setRootError] = useState<string | undefined>(undefined);\n\n  const setRootError = useCallback(\n    (error: string | undefined) => {\n      _setRootError(error);\n      if (pOnRootError !== undefined) {\n        pOnRootError(error);\n      }\n    },\n    [pOnRootError, _setRootError],\n  );\n\n  const [fileStatuses, dispatch] = useReducer(fileStatusReducer, []);\n\n  const isInvalid = useMemo(() => {\n    return (\n      fileStatuses.filter((file) => file.status === \"error\").length > 0 ||\n      rootError !== undefined\n    );\n  }, [fileStatuses, rootError]);\n\n  const _uploadFile = useCallback(\n    async (file: File, id: string, tries = 0) => {\n      const result = await pOnDropFile(file);\n\n      if (result.status === \"error\") {\n        if (autoRetry === true && tries < (maxRetryCount ?? Infinity)) {\n          dispatch({ type: \"update-status\", id, status: \"pending\" });\n          return _uploadFile(file, id, tries + 1);\n        }\n\n        dispatch({\n          type: \"update-status\",\n          id,\n          status: \"error\",\n          error:\n            pShapeUploadError !== undefined\n              ? pShapeUploadError(result.error)\n              : result.error,\n        });\n        if (pOnFileUploadError !== undefined) {\n          pOnFileUploadError(result.error);\n        }\n        return;\n      }\n      if (pOnFileUploaded !== undefined) {\n        pOnFileUploaded(result.result);\n      }\n      dispatch({\n        type: \"update-status\",\n        id,\n        ...result,\n      });\n    },\n    [\n      autoRetry,\n      maxRetryCount,\n      pOnDropFile,\n      pShapeUploadError,\n      pOnFileUploadError,\n      pOnFileUploaded,\n    ],\n  );\n\n  const onRemoveFile = useCallback(\n    async (id: string) => {\n      await pOnRemoveFile?.(id);\n      dispatch({ type: \"remove\", id });\n    },\n    [pOnRemoveFile],\n  );\n\n  const canRetry = useCallback(\n    (id: string) => {\n      const fileStatus = fileStatuses.find((file) => file.id === id);\n      return (\n        fileStatus?.status === \"error\" &&\n        fileStatus.tries < (maxRetryCount ?? Infinity)\n      );\n    },\n    [fileStatuses, maxRetryCount],\n  );\n\n  const onRetry = useCallback(\n    async (id: string) => {\n      if (!canRetry(id)) {\n        return;\n      }\n      dispatch({ type: \"update-status\", id, status: \"pending\" });\n      const fileStatus = fileStatuses.find((file) => file.id === id);\n      if (!fileStatus || fileStatus.status !== \"error\") {\n        return;\n      }\n      await _uploadFile(fileStatus.file, id);\n    },\n    [canRetry, fileStatuses, _uploadFile],\n  );\n\n  const getFileMessageId = (id: string) => `${inputId}-${id}-message`;\n\n  const dropzone = rootUseDropzone({\n    accept: validation?.accept,\n    minSize: validation?.minSize,\n    maxSize: validation?.maxSize,\n    onDropAccepted: async (newFiles) => {\n      setRootError(undefined);\n\n      // useDropzone hook only checks max file count per group of uploaded files, allows going over if in multiple batches\n      const fileCount = fileStatuses.length;\n      const maxNewFiles =\n        validation?.maxFiles === undefined\n          ? Infinity\n          : validation?.maxFiles - fileCount;\n\n      if (maxNewFiles < newFiles.length) {\n        if (shiftOnMaxFiles === true) {\n        } else {\n          setRootError(getRootError([\"too-many-files\"], validation ?? {}));\n        }\n      }\n\n      const slicedNewFiles =\n        shiftOnMaxFiles === true ? newFiles : newFiles.slice(0, maxNewFiles);\n\n      const onDropFilePromises = slicedNewFiles.map(async (file, index) => {\n        if (fileCount + 1 > maxNewFiles) {\n          await onRemoveFile(fileStatuses[index].id);\n        }\n\n        const id = crypto.randomUUID();\n        dispatch({ type: \"add\", fileName: file.name, file, id });\n        await _uploadFile(file, id);\n      });\n\n      await Promise.all(onDropFilePromises);\n      if (pOnAllUploaded !== undefined) {\n        pOnAllUploaded();\n      }\n    },\n    onDropRejected: (fileRejections) => {\n      const errorMessage = getRootError(\n        getDropZoneErrorCodes(fileRejections),\n        validation ?? {},\n      );\n      setRootError(errorMessage);\n    },\n  });\n\n  return {\n    getRootProps: dropzone.getRootProps,\n    getInputProps: dropzone.getInputProps,\n    inputId,\n    rootMessageId,\n    rootDescriptionId,\n    getFileMessageId,\n    onRemoveFile,\n    onRetry,\n    canRetry,\n    fileStatuses: fileStatuses as FileStatus<TUploadRes, TUploadError>[],\n    isInvalid,\n    rootError,\n    isDragActive: dropzone.isDragActive,\n  };\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst DropZoneContext = createContext<UseDropzoneReturn<any, any>>({\n  getRootProps: () => ({}) as never,\n  getInputProps: () => ({}) as never,\n  onRemoveFile: async () => {},\n  onRetry: async () => {},\n  canRetry: () => false,\n  fileStatuses: [],\n  isInvalid: false,\n  isDragActive: false,\n  rootError: undefined,\n  inputId: \"\",\n  rootMessageId: \"\",\n  rootDescriptionId: \"\",\n  getFileMessageId: () => \"\",\n});\n\nconst useDropzoneContext = <TUploadRes, TUploadError>() => {\n  return useContext(DropZoneContext) as UseDropzoneReturn<\n    TUploadRes,\n    TUploadError\n  >;\n};\n\ninterface DropzoneProps<TUploadRes, TUploadError>\n  extends UseDropzoneReturn<TUploadRes, TUploadError> {\n  children: React.ReactNode;\n}\nconst Dropzone = <TUploadRes, TUploadError>(\n  props: DropzoneProps<TUploadRes, TUploadError>,\n) => {\n  const { children, ...rest } = props;\n  return (\n    <DropZoneContext.Provider value={rest}>{children}</DropZoneContext.Provider>\n  );\n};\nDropzone.displayName = \"Dropzone\";\n\ninterface DropZoneAreaProps extends React.HTMLAttributes<HTMLDivElement> {}\nconst DropZoneArea = forwardRef<HTMLDivElement, DropZoneAreaProps>(\n  ({ className, children, ...props }, forwardedRef) => {\n    const context = useDropzoneContext();\n\n    if (!context) {\n      throw new Error(\"DropzoneArea must be used within a Dropzone\");\n    }\n\n    const { onFocus, onBlur, onDragEnter, onDragLeave, onDrop, ref } =\n      context.getRootProps();\n\n    return (\n      // A11y behavior is handled through Trigger. All of these are only relevant to drag and drop which means this should be fine?\n      // eslint-disable-next-line jsx-a11y/no-static-element-interactions\n      <div\n        ref={(instance) => {\n          // TODO: test if this actually works?\n          ref.current = instance;\n          if (typeof forwardedRef === \"function\") {\n            forwardedRef(instance);\n          } else if (forwardedRef) {\n            forwardedRef.current = instance;\n          }\n        }}\n        onFocus={onFocus}\n        onBlur={onBlur}\n        onDragEnter={onDragEnter}\n        onDragLeave={onDragLeave}\n        onDrop={onDrop}\n        {...props}\n        aria-label=\"dropzone\"\n        className={cn(\n          \"flex items-center justify-center rounded-md border border-input bg-background px-4 py-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n          context.isDragActive && \"animate-pulse bg-black/5\",\n          context.isInvalid && \"border-destructive\",\n          className,\n        )}\n      >\n        {children}\n      </div>\n    );\n  },\n);\nDropZoneArea.displayName = \"DropZoneArea\";\n\nexport interface DropzoneDescriptionProps\n  extends React.HTMLAttributes<HTMLParagraphElement> {}\n\nconst DropzoneDescription = forwardRef<\n  HTMLParagraphElement,\n  DropzoneDescriptionProps\n>((props, ref) => {\n  const { className, ...rest } = props;\n  const context = useDropzoneContext();\n  if (!context) {\n    throw new Error(\"DropzoneDescription must be used within a Dropzone\");\n  }\n\n  return (\n    <p\n      ref={ref}\n      id={context.rootDescriptionId}\n      {...rest}\n      className={cn(\"pb-1 text-sm text-muted-foreground\", className)}\n    />\n  );\n});\nDropzoneDescription.displayName = \"DropzoneDescription\";\n\ninterface DropzoneFileListContext<TUploadRes, TUploadError> {\n  onRemoveFile: () => Promise<void>;\n  onRetry: () => Promise<void>;\n  fileStatus: FileStatus<TUploadRes, TUploadError>;\n  canRetry: boolean;\n  dropzoneId: string;\n  messageId: string;\n}\n\nconst DropzoneFileListContext = createContext<\n  DropzoneFileListContext<unknown, unknown>\n>({\n  onRemoveFile: async () => {},\n  onRetry: async () => {},\n  fileStatus: {} as FileStatus<unknown, unknown>,\n  canRetry: false,\n  dropzoneId: \"\",\n  messageId: \"\",\n});\n\nconst useDropzoneFileListContext = () => {\n  return useContext(DropzoneFileListContext);\n};\n\ninterface DropZoneFileListProps\n  extends React.OlHTMLAttributes<HTMLOListElement> {}\n\nconst DropzoneFileList = forwardRef<HTMLOListElement, DropZoneFileListProps>(\n  (props, ref) => {\n    const context = useDropzoneContext();\n    if (!context) {\n      throw new Error(\"DropzoneFileList must be used within a Dropzone\");\n    }\n    return (\n      <ol\n        ref={ref}\n        aria-label=\"dropzone-file-list\"\n        {...props}\n        className={cn(\"flex flex-col gap-4\", props.className)}\n      >\n        {props.children}\n      </ol>\n    );\n  },\n);\nDropzoneFileList.displayName = \"DropzoneFileList\";\n\ninterface DropzoneFileListItemProps<TUploadRes, TUploadError>\n  extends React.LiHTMLAttributes<HTMLLIElement> {\n  file: FileStatus<TUploadRes, TUploadError>;\n}\n\nconst DropzoneFileListItem = forwardRef<\n  HTMLLIElement,\n  DropzoneFileListItemProps<unknown, unknown>\n>(({ className, ...props }, ref) => {\n  const fileId = props.file.id;\n  const {\n    onRemoveFile: cOnRemoveFile,\n    onRetry: cOnRetry,\n    getFileMessageId: cGetFileMessageId,\n    canRetry: cCanRetry,\n    inputId: cInputId,\n  } = useDropzoneContext();\n\n  const onRemoveFile = useCallback(\n    () => cOnRemoveFile(fileId),\n    [fileId, cOnRemoveFile],\n  );\n  const onRetry = useCallback(() => cOnRetry(fileId), [fileId, cOnRetry]);\n  const messageId = cGetFileMessageId(fileId);\n  const isInvalid = props.file.status === \"error\";\n  const canRetry = useMemo(() => cCanRetry(fileId), [fileId, cCanRetry]);\n  return (\n    <DropzoneFileListContext.Provider\n      value={{\n        onRemoveFile,\n        onRetry,\n        fileStatus: props.file,\n        canRetry,\n        dropzoneId: cInputId,\n        messageId,\n      }}\n    >\n      <li\n        ref={ref}\n        aria-label=\"dropzone-file-list-item\"\n        aria-describedby={isInvalid ? messageId : undefined}\n        className={cn(\n          \"flex flex-col justify-center gap-2 rounded-md bg-muted/40 px-4 py-2\",\n          className,\n        )}\n      >\n        {props.children}\n      </li>\n    </DropzoneFileListContext.Provider>\n  );\n});\nDropzoneFileListItem.displayName = \"DropzoneFileListItem\";\n\ninterface DropzoneFileMessageProps\n  extends React.HTMLAttributes<HTMLParagraphElement> {}\n\nconst DropzoneFileMessage = forwardRef<\n  HTMLParagraphElement,\n  DropzoneFileMessageProps\n>((props, ref) => {\n  const { children, ...rest } = props;\n  const context = useDropzoneFileListContext();\n  if (!context) {\n    throw new Error(\n      \"DropzoneFileMessage must be used within a DropzoneFileListItem\",\n    );\n  }\n\n  const body =\n    context.fileStatus.status === \"error\"\n      ? String(context.fileStatus.error)\n      : children;\n  return (\n    <p\n      ref={ref}\n      id={context.messageId}\n      {...rest}\n      className={cn(\n        \"h-5 text-[0.8rem] font-medium text-destructive\",\n        rest.className,\n      )}\n    >\n      {body}\n    </p>\n  );\n});\nDropzoneFileMessage.displayName = \"DropzoneFileMessage\";\ninterface DropzoneMessageProps\n  extends React.HTMLAttributes<HTMLParagraphElement> {}\n\nconst DropzoneMessage = forwardRef<HTMLParagraphElement, DropzoneMessageProps>(\n  (props, ref) => {\n    const { children, ...rest } = props;\n    const context = useDropzoneContext();\n    if (!context) {\n      throw new Error(\"DropzoneRootMessage must be used within a Dropzone\");\n    }\n\n    const body = context.rootError ? String(context.rootError) : children;\n    return (\n      <p\n        ref={ref}\n        id={context.rootMessageId}\n        {...rest}\n        className={cn(\n          \"h-5 text-[0.8rem] font-medium text-destructive\",\n          rest.className,\n        )}\n      >\n        {body}\n      </p>\n    );\n  },\n);\nDropzoneMessage.displayName = \"DropzoneMessage\";\n\ninterface DropzoneRemoveFileProps extends ButtonProps {}\n\nconst DropzoneRemoveFile = forwardRef<\n  HTMLButtonElement,\n  DropzoneRemoveFileProps\n>(({ className, ...props }, ref) => {\n  const context = useDropzoneFileListContext();\n  if (!context) {\n    throw new Error(\n      \"DropzoneRemoveFile must be used within a DropzoneFileListItem\",\n    );\n  }\n  return (\n    <Button\n      ref={ref}\n      onClick={context.onRemoveFile}\n      type=\"button\"\n      size=\"icon\"\n      {...props}\n      className={cn(\n        \"aria-disabled:pointer-events-none aria-disabled:opacity-50\",\n        className,\n      )}\n    >\n      {props.children}\n      <span className=\"sr-only\">Remove file</span>\n    </Button>\n  );\n});\nDropzoneRemoveFile.displayName = \"DropzoneRemoveFile\";\n\ninterface DropzoneRetryFileProps extends ButtonProps {}\n\nconst DropzoneRetryFile = forwardRef<HTMLButtonElement, DropzoneRetryFileProps>(\n  ({ className, ...props }, ref) => {\n    const context = useDropzoneFileListContext();\n\n    if (!context) {\n      throw new Error(\n        \"DropzoneRetryFile must be used within a DropzoneFileListItem\",\n      );\n    }\n\n    const canRetry = context.canRetry;\n\n    return (\n      <Button\n        ref={ref}\n        aria-disabled={!canRetry}\n        aria-label=\"retry\"\n        onClick={context.onRetry}\n        type=\"button\"\n        size=\"icon\"\n        {...props}\n        className={cn(\n          \"aria-disabled:pointer-events-none aria-disabled:opacity-50\",\n          className,\n        )}\n      >\n        {props.children}\n        <span className=\"sr-only\">Retry</span>\n      </Button>\n    );\n  },\n);\nDropzoneRetryFile.displayName = \"DropzoneRetryFile\";\n\ninterface DropzoneTriggerProps\n  extends React.LabelHTMLAttributes<HTMLLabelElement> {}\n\nconst DropzoneTrigger = forwardRef<HTMLLabelElement, DropzoneTriggerProps>(\n  ({ className, children, ...props }, ref) => {\n    const context = useDropzoneContext();\n    if (!context) {\n      throw new Error(\"DropzoneTrigger must be used within a Dropzone\");\n    }\n\n    const { fileStatuses, getFileMessageId } = context;\n\n    const fileMessageIds = useMemo(\n      () =>\n        fileStatuses\n          .filter((file) => file.status === \"error\")\n          .map((file) => getFileMessageId(file.id)),\n      [fileStatuses, getFileMessageId],\n    );\n\n    return (\n      <label\n        ref={ref}\n        {...props}\n        className={cn(\n          \"cursor-pointer rounded-sm bg-secondary px-4 py-2 font-medium ring-offset-background transition-colors focus-within:outline-none hover:bg-secondary/80 has-[input:focus-visible]:ring-2 has-[input:focus-visible]:ring-ring has-[input:focus-visible]:ring-offset-2\",\n          className,\n        )}\n      >\n        {children}\n        <input\n          {...context.getInputProps({\n            style: {\n              display: undefined,\n            },\n            className: \"sr-only\",\n            tabIndex: undefined,\n          })}\n          aria-describedby={\n            context.isInvalid\n              ? [context.rootMessageId, ...fileMessageIds].join(\" \")\n              : undefined\n          }\n          aria-invalid={context.isInvalid}\n        />\n      </label>\n    );\n  },\n);\nDropzoneTrigger.displayName = \"DropzoneTrigger\";\n\ninterface InfiniteProgressProps extends React.HTMLAttributes<HTMLDivElement> {\n  status: \"pending\" | \"success\" | \"error\";\n}\n\nconst valueTextMap = {\n  pending: \"indeterminate\",\n  success: \"100%\",\n  error: \"error\",\n};\n\nconst InfiniteProgress = forwardRef<HTMLDivElement, InfiniteProgressProps>(\n  ({ className, ...props }, ref) => {\n    const done = props.status === \"success\" || props.status === \"error\";\n    const error = props.status === \"error\";\n    return (\n      <div\n        ref={ref}\n        role=\"progressbar\"\n        aria-valuemin={0}\n        aria-valuemax={100}\n        aria-valuetext={valueTextMap[props.status]}\n        {...props}\n        className={cn(\n          \"relative h-2 w-full overflow-hidden rounded-full bg-muted\",\n          className,\n        )}\n      >\n        <div\n          //   TODO: add proper done transition\n          className={cn(\n            \"h-full w-full rounded-full bg-primary\",\n            done ? \"translate-x-0\" : \"animate-infinite-progress\",\n            error && \"bg-destructive\",\n          )}\n        />\n      </div>\n    );\n  },\n);\nInfiniteProgress.displayName = \"InfiniteProgress\";\n\nexport {\n  Dropzone,\n  DropZoneArea,\n  DropzoneDescription,\n  DropzoneFileList,\n  DropzoneFileListItem,\n  DropzoneFileMessage,\n  DropzoneMessage,\n  DropzoneRemoveFile,\n  DropzoneRetryFile,\n  DropzoneTrigger,\n  InfiniteProgress,\n  useDropzone,\n};\n",
      "type": "registry:ui"
    }
  ]
}